---
applyTo: '**/*.rs'
---

# Guide to Context-Generic Programming (CGP) in Rust

This guide gives you a high level overview on how to work with CGP code in Rust.

## Introduction

- CGP is a modular programming paradigm that provides workaround on the coherence restrictions in Rust.
- You can write multiple overlapping or orphan trait implementations implementations in CGP, and then wire them through a concrete context.

## Prelude

- Almost all CGP constructs are imported through the prelude:

```rust
use cgp::prelude::*;
```

## `#[cgp_component]` Macro

- The `#[cgp_component]` macro is used to enable CGP capabilities on a trait. For example:

```rust
#[cgp_component(HashProvider)]
pub trait CanHash {
    fn hash<H: Hasher>(&self, state: &mut H);
}
```

- The original trait, i.e. `CanHash`, is now called a **consumer trait**.
- A CGP consumer trait is typically named in the verb format, e.g. `CanDoSomething`.
- We also call the fully expanded constructs a CGP trait, or a CGP component. For example, the full constructs can be called the `HashProvider` component.

## Provider Traits

- The argument to `#[cgp_component]` is the name of the **provider trait**, which is generated by the macro as follows:

```rust
pub trait HashProvider<Context> {
    fn hash<H: Hasher>(context: &Context, state: &mut H);
}
```

- In the provider trait, the original `Self` type is moved to an explicit generic parameter called `Context`.
- All references to the original `self` or `Self` are converted to refer to `context` or `Context`.
- The new `Self` position in the provider trait will be implemented by unique and dummy provider types, which will act as the provider's name.
- A CGP provider trait is typically named in the noun format, e.g. `SomethingDoer`. When no suitable postfix is avaiable, the `Provider` postfix is used instead, e.g. `SomethingProvider`.

- For example, one can write a blanket implementation for `HashProvider` as follows:

```rust
pub struct HashWithDisplay;

impl<Context: Display> HashProvider<Context> for HashWithDisplay { ... }
```

- The provider name `HashWithDisplay` is defined as a local dummy struct.
- The implementation of `HashProvider` can be generic over any `Context` type that implements `Display`.
- The usual coherence restrictions don't apply, because the `Self` type `HashWithDisplay` is owned by the same crate.
- This allows any number of such blanket provider trait implementations to be defined in any crate.

## Component Name

- The macro generates a component name type with a `Component` postfix, i.e.:

```rust
pub struct HashProviderComponent;
```

- The macro also generates blanket implementations to allow delegation of the implementation of a consumer or provider trait to a different provider, which will be explained later.

## `DelegateComponent` Trait

- The `DelegateComponent` trait is defined as follows:

```rust
pub trait DelegateComponent<Component: ?Sized> {
    type Delegate;
}
```

- This is mainly used to turn a type implementing `DelegateComponent` into a type-level table.
- The `Component` generic parameter acts as the "key" type, and the `Delegate` associated type acts as the "value" type to be read from the type-level table.

- For example, given the following:

```rust
impl DelegateComponent<Foo> for MyComponents {
    type Delegate = Bar;
}
```

- The code above "sets"  the entry `Foo` in the `MyComponents` table to have `Bar` as the "value" type.

## Consumer Trait Delegation

- The `#[cgp_component]` macro generates the following blanket implementation for the example `CanHash` consumer trait earlier:

```rust
impl<Context> CanHash for Context
where
    Context: DelegateComponent<HashProviderComponent>,
    Context::Delegate: HashProvider<Context>,
{
    fn hash<H: Hasher>(&self, state: &mut H) {
        Context::Delegate::hash(self, state)
    }
}
```

- The blanket implementation essentially uses the generated `HashProviderComponent` struct as a key, and reads the entry stored on `Context`'s type-level table.
- If the `Delegate` "value" type implements the provider trait `HashProvider` for the `Context` type, then `Context` would automatically implement the `CanHash` consumer trait through the blanket implementation.
- The example `CanHash` method body is implemented by calling the `CanHash` method from the delegated provider.

- Following the earlier example, this allows the consumer trait to be defined on a custom context such as follows:

```rust
pub struct Person { ... }
impl Display for Person { ... }

impl DelegateComponent<HashProviderComponent> for Person {
    type Delegate = HashWithDisplay;
}
```

- The example `Person` struct above implements `Display`, and then delegate the implementation of `CanHash` to the `HashWithDisplay` provider.
- This is done by implementing `DelegateComponent` with `HashProviderComponent` used as the "key", and `HashWithDisplay` used as the "value" for `Person`'s type-level table.
- With that, `Person` now implements `CanHash` through the blanket implementation.

## Provider Trait Delegation

- The `#[cgp_component]` macro also generates a blanket implementation for the provider trait, similar to the consumer trait:

```rust
impl<Context, Provider> HashProvider<Context> for Provider
where
    Provider: DelegateComponent<HashProviderComponent>,
    Provider::Delegate: HashProvider<Context>,
{
    fn hash<H: Hasher>(context: &Context, state: &mut H) {
        Context::Delegate::hash(context, state)
    }
}
```

- Essentially, this allows a provider to delegate the implementation of a provider trait to another provider.
- The blanket implementation use `Provider` as the type-level table, and perform the same lookup using `HashProviderComponent` as the key.
- This is useful for constructing intermediary "tables" that assemble multiple CGP providers that implement different CGP components.

## `delegate_components!` Macro

- The `delegate_components!` macro is commonly used to simplify the definition of type-level tables through the `DelegateComponent` trait.
- For example, the earlier example delegation for `Person` can be redefined as:

```rust
delegate_components! {
    Person {
        HashProviderComponent:
            HashWithDisplay,
    }
}
```

- The first argument to `delegate_components!`, i.e. `Person`, designates the target type where the type-level table is defined, or which the `DelegateComponent` trait will be implemented by.
